/**
 * Section-to-Expert Mapping
 *
 * Maps navigation sections to their responsible expert agents.
 * Some experts cover multiple sections (e.g., costs expert also generates calc-sheet).
 *
 * This enables:
 * 1. Selective re-scan of specific sections
 * 2. Progress tracking per section
 * 3. Quality badges per section based on expert confidence
 */

/**
 * Maps each navigation section ID to its responsible expert
 */
export const SECTION_TO_EXPERT: Record<string, string> = {
  // Overview is generated by project expert
  overview: 'project',

  // Base sections - 1:1 mapping
  technology: 'tech',
  'website-analysis': 'website',
  'cms-architecture': 'architecture',
  hosting: 'hosting',
  integrations: 'integrations',
  migration: 'migration',

  // Architecture expert also handles CMS comparison
  'cms-comparison': 'architecture',

  // Synthesis sections
  'project-org': 'project',
  costs: 'costs',

  // Costs expert also generates calc-sheet
  'calc-sheet': 'costs',

  // Decision expert
  decision: 'decision',

  // Audit section is handled by performance expert
  audit: 'performance',
};

/**
 * Maps each expert to the sections it generates
 */
export const EXPERT_TO_SECTIONS: Record<string, string[]> = {
  scraper: [], // Scraper doesn't generate sections directly
  tech: ['technology'],
  website: ['website-analysis'],
  performance: ['audit'],
  architecture: ['cms-architecture', 'cms-comparison'],
  hosting: ['hosting'],
  integrations: ['integrations'],
  migration: ['migration'],
  project: ['project-org', 'overview'],
  costs: ['costs', 'calc-sheet'],
  decision: ['decision'],
};

/**
 * All navigation section IDs
 */
export const ALL_SECTIONS = Object.keys(SECTION_TO_EXPERT);

/**
 * All expert names in execution order
 */
export const ALL_EXPERTS = [
  'scraper',
  'tech',
  'website',
  'performance',
  'architecture',
  'hosting',
  'integrations',
  'migration',
  'project',
  'costs',
  'decision',
] as const;

/**
 * Maps internal expert names to display names (for UI)
 */
export const EXPERT_DISPLAY_NAMES: Record<string, string> = {
  scraper: 'Scraper',
  tech: 'Tech Expert',
  website: 'Website Expert',
  performance: 'Performance Expert',
  architecture: 'Architecture Expert',
  hosting: 'Hosting Expert',
  integrations: 'Integrations Expert',
  migration: 'Migration Expert',
  project: 'Project Expert',
  costs: 'Costs Expert',
  decision: 'Decision Expert',
};

/**
 * Sections that should be excluded from re-scan options
 * (debug sections, etc.)
 */
export const EXCLUDED_FROM_RESCAN = ['rag-data'];

/**
 * Get the expert responsible for a section
 *
 * @param sectionId - Navigation section ID
 * @returns Expert name or undefined if not found
 */
export function getExpertForSection(sectionId: string): string | undefined {
  return SECTION_TO_EXPERT[sectionId];
}

/**
 * Get all sections generated by an expert
 *
 * @param expertName - Expert name
 * @returns Array of section IDs
 */
export function getSectionsForExpert(expertName: string): string[] {
  return EXPERT_TO_SECTIONS[expertName] || [];
}

/**
 * Convert selected sections to required experts
 *
 * @param sectionIds - Array of section IDs selected for re-scan
 * @returns Array of unique expert names needed
 */
export function sectionsToExperts(sectionIds: string[]): string[] {
  const experts = sectionIds
    .map(id => SECTION_TO_EXPERT[id])
    .filter((expert): expert is string => expert !== undefined);

  return [...new Set(experts)];
}

/**
 * Get all sections that would be affected by re-running an expert
 * (including dependent experts' sections)
 *
 * @param expertName - Expert name
 * @param includeDependents - Whether to include sections from dependent experts
 * @returns Array of section IDs
 */
export function getAffectedSections(expertName: string, includeDependents = false): string[] {
  const sections = getSectionsForExpert(expertName);

  if (includeDependents) {
    // Import dynamically to avoid circular dependency
    // In practice, this would be pre-computed or the function would live elsewhere
    const { getDependentExperts } = require('./expert-dependencies');
    const dependents = getDependentExperts(expertName) as string[];

    for (const dependent of dependents) {
      sections.push(...getSectionsForExpert(dependent));
    }
  }

  return [...new Set(sections)];
}

/**
 * Quality badge configuration based on confidence scores
 */
export interface QualityBadge {
  label: string;
  variant: 'success' | 'warning' | 'caution' | 'destructive';
  color: string;
}

/**
 * Get quality badge for a confidence score
 *
 * @param confidence - Confidence score (0-100)
 * @returns Quality badge configuration
 */
export function getQualityBadge(confidence: number): QualityBadge {
  if (confidence >= 80) {
    return { label: 'Gut', variant: 'success', color: 'bg-green-500' };
  }
  if (confidence >= 60) {
    return { label: 'Akzeptabel', variant: 'warning', color: 'bg-yellow-500' };
  }
  if (confidence >= 40) {
    return { label: 'Verbesserungsw√ºrdig', variant: 'caution', color: 'bg-orange-500' };
  }
  return { label: 'Niedrig', variant: 'destructive', color: 'bg-red-500' };
}
