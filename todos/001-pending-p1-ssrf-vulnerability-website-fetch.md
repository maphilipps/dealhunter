---
status: pending
priority: p1
issue_id: '001'
tags: [code-review, security, quick-scan]
dependencies: []
---

# SSRF Vulnerability in Website URL Fetching

## Problem Statement

The Quick Scan feature allows user-controlled URL fetching without validation against internal/private IP ranges. This creates a **Server-Side Request Forgery (SSRF)** vulnerability where malicious users could scan internal networks or access localhost services.

**Impact:** HIGH - Could expose internal services, bypass firewalls, or leak sensitive data from internal endpoints.

**Location:** `/Users/marc.philipps/Sites/dealhunter/lib/quick-scan/agent.ts:101`

## Findings

**From security-sentinel agent:**

```typescript
// Current code - VULNERABLE
const response = await fetch(fullUrl, {
  headers: {
    'User-Agent': 'Mozilla/5.0 (compatible; DealhunterBot/1.0)',
  },
  signal: AbortSignal.timeout(10000),
});
```

**Attack Vector:**

1. User provides malicious URL in extraction: `http://localhost:6379/` (Redis)
2. Quick Scan fetches internal service
3. Response data could leak sensitive information
4. Could be used to port-scan internal network

**Current Validation:** NONE - Any URL is accepted and fetched.

## Proposed Solutions

### Solution 1: IP Range Blocklist (Recommended)

**Effort:** Small
**Risk:** Low
**Pros:** Simple, effective, industry standard
**Cons:** Requires maintenance for cloud provider IP ranges

```typescript
function isInternalUrl(url: string): boolean {
  const parsed = new URL(url);
  const hostname = parsed.hostname;

  // Block localhost
  if (hostname === 'localhost' || hostname === '127.0.0.1') return true;

  // Block private networks (RFC 1918)
  const ipRegex = /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/;
  const match = hostname.match(ipRegex);
  if (match) {
    const [, a, b, c, d] = match.map(Number);
    // 10.x.x.x
    if (a === 10) return true;
    // 172.16.x.x - 172.31.x.x
    if (a === 172 && b >= 16 && b <= 31) return true;
    // 192.168.x.x
    if (a === 192 && b === 168) return true;
    // 169.254.x.x (link-local)
    if (a === 169 && b === 254) return true;
  }

  return false;
}

// In fetchWebsiteContent:
if (isInternalUrl(fullUrl)) {
  throw new Error('Cannot fetch internal URLs');
}
```

### Solution 2: Domain Whitelist

**Effort:** Medium
**Risk:** Low
**Pros:** Most secure, explicit control
**Cons:** Requires pre-approval of domains, may frustrate users

Allow only publicly registered domains (no IP addresses):

```typescript
function isPublicDomain(url: string): boolean {
  const parsed = new URL(url);

  // Block IP addresses entirely
  if (/^\d+\.\d+\.\d+\.\d+$/.test(parsed.hostname)) {
    return false;
  }

  // Require valid TLD
  const tldRegex = /\.(com|de|org|net|io|app)$/i;
  return tldRegex.test(parsed.hostname);
}
```

### Solution 3: Use External Scraping Service (Long-term)

**Effort:** Large
**Risk:** Low
**Pros:** Offloads security to third-party, better reliability
**Cons:** Adds dependency, cost

Integrate Exa.ai (already in dependencies) or similar service that handles URL validation.

## Recommended Action

**Implement Solution 1 immediately** (IP range blocklist) as it provides strong protection with minimal effort. Add Solution 2 (domain whitelist) in a future iteration if additional security is needed.

## Technical Details

**Affected Files:**

- `/Users/marc.philipps/Sites/dealhunter/lib/quick-scan/agent.ts` (add validation before fetch)
- Create `/Users/marc.philipps/Sites/dealhunter/lib/utils/url-validation.ts` (new utility module)

**Database Changes:** None

**Breaking Changes:** No - only rejects previously unvalidated URLs

## Acceptance Criteria

- [ ] `isInternalUrl()` function blocks localhost, 127.0.0.1, and RFC 1918 private IPs
- [ ] `fetchWebsiteContent()` throws error for internal URLs before fetching
- [ ] Unit tests cover all blocked IP ranges (10.x, 172.16-31.x, 192.168.x, 169.254.x)
- [ ] Integration test verifies SSRF attack is blocked
- [ ] Error message clearly explains why URL was rejected

## Work Log

<!-- Add dated entries as you work on this -->

## Resources

- OWASP SSRF: https://owasp.org/www-community/attacks/Server_Side_Request_Forgery
- RFC 1918 Private Networks: https://datatracker.ietf.org/doc/html/rfc1918
- Security Sentinel Review: See agent output above
